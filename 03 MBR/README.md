# 解说
cpu如何和其他硬件交互。
## 和自己/函数调用
刚学C语言的时候，我就觉得函数是个很神奇的东西，长久没搞清楚其中的奥秘。
对我来说函数神奇的地方在于，你可以在任何地方调用它，而他本身只存在于一处。我猜过不少实现方法，都不太对劲。直到乱翻书知道大概的做法，眼泪掉下来。
### 普通调用

	int foo(int a) {
	    return a++;
	}
	
	int bar=123;
	int baz=foo(bar);
	
用上面的代码为例，我曾经以为是函数**foo**去找**bar**的位置，然后计算，然后返回。这个方式下，"找"这个行为就很难实现。

实际的过程是，**bar**把自己复制一份放到一个约定好的地方，一旦**foo**
被调用了，他就可以直接得到**bar**的值，虽然不是原来的**bar**，但是值一样，那就没区别。然后做完了放到规定的地方，调用回来之后，baz把那个规定地方的值赋给自己，一切看上去都没问题。

### 函数返回
函数调用了，cs:ip就指到函数那里来，原来的地方回不去了。。。
那样不行，所以cs:ip在函数调用的时候，隐含地也会复制一份给函数，让他执行完了再把cs:ip置回来。这样一个调用才算完成。

### 嵌套调用
再看一例

	int foo(int a) {
	      return foo(a+1);
	}
	foo(0);
	
不用管这是个死循环，这里只是想写一段短代码演示。要演示的是上面说的**"固定的地方"**其实是不可行的，如果真的写在固定的地方，那么一轮过后，值就被覆盖掉了。要是考虑上面说的函数返回问题，那就是回不去了。

这里的解决办法是**栈**。额外开一段内存用来存这些函数环境，复制的参数，返回的地址，还有栈顶的位置。给出栈顶的位置，可以在调用完了之后弹栈，把这个函数相关的东西清掉，也直接指示出当前函数的环境是哪个。

> | foo(3)     | <-----现在在这里，也是栈顶  
> | foo(2)     |  
> | foo(1)     |  
> | foo(0)     | <----栈底  
> - - - - - - - -


### 中断
抛开一些特殊的性质，调用来调用去的方面，他和函数其实是一样的。只是他不在内存里放参数，他放寄存器里。

## I/O接口

> 显示器  ------- 显卡-----\  
> 硬盘 -硬盘控制器-------主板 ------cpu  
> 音箱 --------声卡---------/


### 硬盘
是IO接口的示例，硬盘历史上很早就把相当于显卡之于显示器，声卡之于音箱的硬盘控制器做进了硬盘。所以一切cpu和硬盘打交道的接口其实都是在和硬盘控制器打交道。

IO接口,其实都是对应硬件的寄存器，对应交流的汇编，是2个特殊命令`in`和`out`，分别表示从接口读和往接口写。后面接2个操作数，代表了io接口的地址和要传的值。同一个io接口地址，读和写的时候的功能还不一定是一样的。比如有的写的时候是写入参数的，此时叫做feature寄存器，但是读取的时候读到的是错误码，叫error寄存器。然后他们对应io接口地址是同一个。奇妙混乱。

书上说硬盘接口分2种，Control Block registers和Command Block registers。

命令块寄存器是可以对寄存器读写信息用的，比如读取硬盘准备好的数据，检查硬盘状态。此外读和写的时候
而控制块寄存器，是用来下命令的。前面命令块相当于填参数，而控制块写入时，不仅仅是写了命令，而且相当于一次commit，此时硬盘会执行真正的命令。

### 显卡
我觉得显卡这部分是多余的，完全是为了IO接口叙述的完整性才放到这里来的，不过后面还没看怕打脸还是写几句。
显卡和硬盘不同，是用另一种IO通信方式来交互的，即通过内存地址映射来交互。
你往类似内存的地址0xb8000写东西，实际是写到显存里去，然后反映到显示器上，这样完成操作显示器的目的。
概念上是这样的

	cpu         -->> 显卡(显示器适配器)      -->> 显示器

显示相关的地址是0xA0000-0xC7FFF，其中0xB0000-0xBFFFF，32KB是用来显示文字的，往里写ASCII码就会出字。

-

# 工具
nasm 直接用包管理装。

dd 应该是系统自带的

# 原料
在`03 MBR`
```
	nasm -o ../bin/mbr.bin mbr.S
	nasm -o ../bin/loader.bin loader.S
```

`bin`
```
	dd if=mbr.bin of=hd60M.img bs=512 count=1 conv=notrunc
	dd if=loader.bin of=hd60M.img bs=512 count=1 seek=2 conv=notrunc
```

# 代码解释
-  `boot.inc`
  是简单的宏定义，当一个配置文件的。语法就是   
   ```
   MACRONAME equ value
   ```

- `mbr.S`
  先是初始化寄存器，然后调用 `rd_disk_m_16` 把硬盘上的loader读到内存中去。最后`jmp LOADER_BASE_ADDR` 跳转到loader开始执行。

  底下是一堆可怕的细节。需要操作硬盘IO接口的知识。其中还有一堆硬编码，如果独立写，要去查对应的手册。

  基本做的就是，保存寄存器，设置读取硬盘的地址（39行～56行，很简单的赋值要写这么长- -），读取扇区个数等参数，然后轮训等待硬盘，最后读取数据返回。

- `loader.S`
  这个阶段还什么都没做……仅仅又是往显存写入`"LOADER"`之后`jmp $`死循环

