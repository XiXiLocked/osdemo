# 解说
cpu如何和其他硬件交互。
## 和自己/函数调用
刚学C语言的时候，我就觉得函数是个很神奇的东西，长久没搞清楚其中的奥秘。
对我来说函数神奇的地方在于，你可以在任何地方调用它，而他本身只存在于一处。我猜过不少实现方法，都不太对劲。直到乱翻书知道大概的做法，眼泪掉下来。
### 普通调用

	int foo(int a) {
	    return a++;
	}
	
	int bar=123;
	int baz=foo(bar);
	
用上面的代码为例，我曾经以为是函数**foo**去找**bar**的位置，然后计算，然后返回。这个方式下，"找"这个行为就很难实现。

实际的过程是，**bar**把自己复制一份放到一个固定的地方，一旦**foo**
被调用了，他就可以直接得到**bar**的值，虽然不是原来的**bar**，但是值一样，那就没区别。然后做完了放到规定的地方，调用回来之后，baz把那个规定地方的值赋给自己，一切看上去都没问题。

### 函数返回
函数调用了，cs:ip就指到函数那里来，原来的地方回不去了。。。
那样不行，所以cs:ip在函数调用的时候，隐含地也会复制一份给函数，让他执行完了再把cs:ip置回来。这样一个调用才算完成。

### 嵌套调用
再看一例

	int foo(int a) {
	      return foo(a+1);
	}
	foo(0);
	
不用管这是个死循环，这里只是想写一段短代码演示。要演示的是上面说的**"固定的地方"**其实是不可行的，如果真的写在固定的地方，那么一轮过后，值就被覆盖掉了。要是考虑上面说的函数返回问题，那就是回不去了。

这里的解决办法是**栈**。额外开一段内存用来存这些函数环境，复制的参数，返回的地址，还有栈顶的位置。给出栈顶的位置，可以在调用完了之后弹栈，把这个函数相关的东西清掉，也直接指示出当前函数的环境是哪个。

> | foo(3)     | <-----现在在这里，也是栈顶
> | foo(2)     |
> | foo(1)     |
> | foo(0)     | <----栈底
> - - - - - - - -


### 中断
抛开一些特殊的性质，调用来调用去的方面，他和函数其实是一样的。只是他不在内存里放参数，他放寄存器里。

## I/O接口

> 显示器  ------- 显卡-----\
> 硬盘 -硬盘控制器-------主板 ------cpu
> 音箱 --------声卡---------/


### 硬盘


### 显卡
我觉得显卡这部分是多余的，完全是为了IO接口叙述的完整性才放到这里来的，不过后面还没看怕打脸还是写几句。
显卡和硬盘不同，是用另一种IO通信方式来交互的，即通过内存地址映射来交互。
你往类似内存的地址0xb8000写东西，实际是写到显存里去，然后反映到显示器上，这样完成操作显示器的目的。
概念上是这样的

	cpu         -->> 显卡(显示器适配器)      -->> 显示器

显示相关的地址是0xA0000-0xC7FFF，其中0xB0000-0xBFFFF，32KB是用来显示文字的，往里写ASCII码就会出字。

-

# 工具
nasm 直接用包管理装。

dd 应该是系统自带的

# 原料
在02 Boot里

	nasm -o mbr.bin mbr.S
	
	dd if=mbr.bin of=../bin/hd60M.img bs=512 count=1 conv=notrunc
